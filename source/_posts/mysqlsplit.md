---
title: 数据库分库分表小结
date: 2018-01-18 17:08:34
tags:
  - mysql mybatis
  - tech

---

### 背景

> 作为一个数据库，作为数据库中的一张表，随着用户的增多随着时间的推移，总有一天，数据量会大到一个难以处理的地步。这时仅仅一张表的数据就已经超过了千万，无论是查询还是修改，对于它的操作都会很耗时，这时就需要进行数据库切分的操作了。


### Mybatis 分表简单实现

1、我们模拟用户表数据量超过千万（虽然实际不太可能）

2、用户表原来的名字叫做user_tab，我们切分为user_tab_0和user_tab_1（实际也可能不是这么随意的名字），这样就能把原来千万的数据分离成两个百万的数据量的两张表了。

3、如何操作这两张表呢？我们利用userId也就是用户的唯一标识进行区分。

4、userId%2 == 0的用户操作表user_tab_0，同理userId%2 == 1的用户操作表user_tab_1

5、那么在MyBatis中sql语句如何实现呢？下面是举例查询一个用户的sql语句

```sql
<select id="getUser" parameterType="java.util.Map" resultType="UserDO"> 
    SELECT userId, name 
    FROM user_tab_#{tabIndex} 
    WHERE userId = #{userId} 
</select>
```

以上就是最简单的实现，不需要多余的框架，不需要任何的插件也就满足了分表的要求。

### 分离的方式

切分的方式主要有两种，水平切分和垂直切分。

1、水平切分

简单的说就是，把一张表分离成几张一模一样的表，然后表的名字不同。就和上面最简单的例子一样。

这种切分适合于一张表的数据量过大而导致操作时间变慢的情况，如保存的一些记录表。

2、垂直切分

把不同的业务模块分成不同的数据库，这些业务模块直接最好是0耦合（简单的说就是毫无关系）。

这主要是适合数据量普遍较大，而且业务场景比较分散，互相之间没有逻辑关系的情况。


### 分离的策略

具体的策略有很多种，你也可以设计你自己的，普遍的策略有下面几种，只是列举就不具体展开了。

1、“%”取模，也就是上面例子中实现的，也是最简单的一种。

2、MD5哈希

3、移位

4、日期时间（根据不同的日期分表，如一个月一张表，这个月就操作这张表，下个月就下张表）

5、枚举范围（用户1-10000操作第一张表，用户10001-20000操作第二张表）

### 分离的问题

下面说说最终要的点，导致的问题。

数据库肯定不是你说分就分的。（人家比较有感情的，怎么能说分就分呢？）

正经来说，我列举了下面几个分离只有会导致的问题。

1、添加时主键唯一性的问题；分离之后多张表，就会导致原有的自增长主键不唯一，所以没有办法自增长了，导致问题，解决方案的也是有的，比如单独维护一张主键表专门用来存放当前主键，或者说用别的中间件等。

2、新增时的效率问题，虽然不是个大问题，但是新增肯定会多了计算量嘛，这个问题可以忽略不计。

3、查询所带来的分页问题，分离成多张表之后，分页查询就很困难了，这也考虑到不同的分离用不同的解决方案，总之会产生问题。

4、同理，关联查询，原本一张表关联别的表或者别的表关联一张表，都很简单，但是现在分离之后就难了。

5、事务问题，多张表需要使用分布式事务才能完成原来带有事务的操作。因为原来的事务只是锁一张表现在可能要锁多张了呢。

6、扩展性问题，有的切分策略下，对数据的扩展性其实不好，之后如果有更多的数据来了，是说还能再新建表来扩展吗？

### 分离的原则

下面总结了几点分离的原则，主要是参考了网络上的，没有任何实际的依据（我也不是个年薪百万的DBA也碰不到那么大的数据去实际检验嘛），所以如果有任何问题也请指出。

1、能不分就不分

2、能分少就不分多

3、多冗余，不关联

4、避免使用分布式事务，主要是太难我也不会啊

5、单表千万记录以内就不分

6、现在不分以后分也来得及

7、扩展，耦合，仔细考虑

### 实现分离的方式

最后说说分离的方式，现在流行使用的DAO框架是MyBatis，也有很多别的框架。分离的实现主要有下面几种方式。

1、原生实现，就和最上面的例子一样，不需要其他任何的东西，利用原生的框架，自己去控制实现。

优点是：容易控制，掌握主动权。

缺点是：代码量多，需要自己很清楚，修改不方便，不支持复杂的切分，比如切分之后还需要做一些分页查询，还有上面说的主键问题等。

2、插件实现，利用框架本身开发的一些插件，去实现这些插件，然后利用插件去访问数据库，直接实现分离。

优点是：代码量少，实现简单，扩展性好。

缺点是：不易控制，分离方式有限，出现问题难以解决。没有找到特别成熟的插件。

3、中间件实现。利用一些数据库访问的中间件，在访问数据库之前做一些操作使得sql进行相应的变化从而实现分离。

优点是：耦合小，扩展性好，可以解决分布式事务的问题。

确定是：实现比较复杂，需要对中间件进行学习，成本较大。维护也是一个大问题，万一挂掉了。。


### 小结

总之方式各有千秋，但是考虑到成本上面，第一种几乎是0成本，即可上手，而且比较容易控制，就如同最上面给出的例子一样，而且当前我处理的数据还没有到达那种处处要分离的地步，所以我选择第一种。也推荐使用。
